import fs from 'fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { createClient } from '@supabase/supabase-js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Config and paths
const PROJECT_ROOT = path.resolve(__dirname, '..');
const UPLOAD_TXT = path.resolve('/workspace/uploads/jeju.txt');
const SEED_JSON = path.resolve(PROJECT_ROOT, 'supabase/seed/from_jeju_txt.json');
const SCHEMA_SQL = path.resolve(PROJECT_ROOT, 'supabase/schema.sql');
const MAPPING_MD = path.resolve(PROJECT_ROOT, 'docs/data_mapping.md');
const LOG_DIR = path.resolve(PROJECT_ROOT, 'logs');
const LOG_PATH = path.resolve(LOG_DIR, 'etl_validation.log');

// Env
const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL || '';
const SUPABASE_ANON = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || '';
// Support both service secret (preferred) and legacy service_role JWT (fallback)
const SUPABASE_SERVICE_SECRET = process.env.SUPABASE_SERVICE_SECRET || '';
const SUPABASE_SERVICE_ROLE = process.env.SUPABASE_SERVICE_ROLE || '';
const SUPABASE_SERVICE_KEY = SUPABASE_SERVICE_SECRET || SUPABASE_SERVICE_ROLE || '';
const INSERT_ONLY = (() => {
  const v = String(process.env.ETL_INSERT_ONLY || '').toLowerCase();
  return v === '1' || v === 'true' || v === 'yes' || v === 'on';
})();

function ts() {
  return new Date().toISOString();
}
function mask(v) {
  if (!v) return 'undefined';
  try {
    if (v.length <= 10) return '****';
    return `${v.slice(0, 4)}...${v.slice(-4)}`;
  } catch {
    return '****';
  }
}

async function ensureLogDir() {
  try {
    await fs.mkdir(LOG_DIR, { recursive: true });
  } catch {}
}

async function logLine(level, msg) {
  await ensureLogDir();
  const line = `[${ts()}] [${level}] ${msg}\n`;
  await fs.appendFile(LOG_PATH, line, 'utf8');
  console.log(line.trim());
}

async function logInfo(msg) { return logLine('INFO', msg); }
async function logError(msg) { return logLine('ERROR', msg); }
async function logWarn(msg) { return logLine('WARN', msg); }

function supabaseClient(key) {
  if (!SUPABASE_URL || !key) return null;
  return createClient(SUPABASE_URL, key, { auth: { persistSession: false } });
}

async function readJsonSafe(file) {
  try {
    const buf = await fs.readFile(file, 'utf8');
    return JSON.parse(buf);
  } catch {
    return null;
  }
}

async function writeFileSafe(file, content) {
  await fs.mkdir(path.dirname(file), { recursive: true });
  await fs.writeFile(file, content, 'utf8');
}

async function generateSchemaAndDocsPlaceholders() {
  try {
    await fs.access(SCHEMA_SQL);
  } catch {
    const ddl = `-- Schema placeholder. Apply actual DDL in Supabase Studio.\n`;
    await writeFileSafe(SCHEMA_SQL, ddl);
    await logInfo(`schema.sql written: ${SCHEMA_SQL}`);
  }
  try {
    await fs.access(MAPPING_MD);
  } catch {
    const doc = `# Data Mapping\n\nThis document describes the mapping from jeju.txt to normalized tables.\n(Autogenerated placeholder; see previous runs for detailed rules.)\n`;
    await writeFileSafe(MAPPING_MD, doc);
    await logInfo(`Mapping doc written: ${MAPPING_MD}`);
  }
}

async function loadOrCreateSeed() {
  let seed = await readJsonSafe(SEED_JSON);
  if (seed && (seed.categories || seed.places)) {
    await logInfo(`Seed JSON loaded: ${SEED_JSON} (categories=${seed.categories?.length ?? 0}, places=${seed.places?.length ?? 0}, schedules=${seed.schedules?.length ?? 0}, schedule_places=${seed.schedule_places?.length ?? 0})`);
    return seed;
  }
  let text = '';
  try { text = await fs.readFile(UPLOAD_TXT, 'utf8'); } catch {}
  await logWarn('Seed JSON not found. Falling back to minimal parse of jeju.txt (may produce empty sets).');
  const categories = [];
  const places = [];
  const schedules = [];
  const schedule_places = [];
  seed = { categories, places, schedules, schedule_places };
  await writeFileSafe(SEED_JSON, JSON.stringify(seed, null, 2));
  await logInfo(`Seed JSON written: ${SEED_JSON} (categories=${categories.length}, places=${places.length}, schedules=${schedules.length}, schedule_places=${schedule_places.length})`);
  return seed;
}

// Sanitize rows against known schema to avoid unknown-column errors (e.g., 'source_id')
function pick(obj, keys) {
  const out = {};
  for (const k of keys) {
    if (obj[k] !== undefined) out[k] = obj[k];
  }
  return out;
}
function toNumOrNull(v) {
  if (v === null || v === undefined || v === '') return null;
  const n = Number(v);
  return Number.isFinite(n) ? n : null;
}
function sanitizeCategories(rows) {
  const cols = ['key', 'name', 'id']; // allow id if present, though not required
  return rows.map((r) => pick(r, cols));
}
function sanitizePlaces(rows) {
  const cols = ['id','name','category_key','lat','lng','image','description','time','fee','url'];
  return rows.map((r) => {
    const o = pick(r, cols);
    if ('lat' in o) o.lat = toNumOrNull(o.lat);
    if ('lng' in o) o.lng = toNumOrNull(o.lng);
    return o;
  });
}
function sanitizeSchedules(rows) {
  const cols = ['id','title','created_at'];
  return rows.map((r) => pick(r, cols));
}
function sanitizeSchedulePlaces(rows) {
  const cols = ['schedule_id','place_id','order_index','time_str'];
  return rows.map((r) => pick(r, cols));
}

async function validateWithAnon() {
  const anon = supabaseClient(SUPABASE_ANON);
  if (!anon) {
    await logWarn('VALIDATION skipped: anon client not initialized (missing URL or anon key)');
    return;
  }
  await logInfo('VALIDATION Start');
  try {
    const { count, error } = await anon.from('categories').select('id', { count: 'exact', head: true });
    if (error) await logError(`[VALIDATION][categories.count] code=${error.code ?? ''} msg=${error.message ?? ''}`);
    else await logInfo(`VALIDATION categories count = ${count ?? 0}`);
    const { data, error: e2 } = await anon.from('categories').select('id,key,name,created_at').order('id', { ascending: true }).limit(3);
    if (e2) await logError(`[VALIDATION][categories.sample] code=${e2.code ?? ''} msg=${e2.message ?? ''}`);
    else await logInfo(`VALIDATION categories sample (up to 3): ${JSON.stringify(data ?? [])}`);
  } catch (e) { await logError(`[VALIDATION][categories] unexpected ${e?.message || e}`); }

  try {
    const { count, error } = await anon.from('places').select('id', { count: 'exact', head: true });
    if (error) await logError(`[VALIDATION][places.count] code=${error.code ?? ''} msg=${error.message ?? ''}`);
    else await logInfo(`VALIDATION places count = ${count ?? 0}`);
    const { data, error: e2 } = await anon.from('places').select('id,name,category_key,lat,lng,image,description,time,fee,url,created_at').order('id', { ascending: true }).limit(3);
    if (e2) await logError(`[VALIDATION][places.sample] code=${e2.code ?? ''} msg=${e2.message ?? ''}`);
    else await logInfo(`VALIDATION places sample (up to 3): ${JSON.stringify(data ?? [])}`);
  } catch (e) { await logError(`[VALIDATION][places] unexpected ${e?.message || e}`); }

  try {
    const { count, error } = await anon.from('schedules').select('id', { count: 'exact', head: true });
    if (error) await logError(`[VALIDATION][schedules.count] code=${error.code ?? ''} msg=${error.message ?? ''}`);
    else await logInfo(`VALIDATION schedules count = ${count ?? 0}`);
    const { data, error: e2 } = await anon.from('schedules').select('id,title,created_at').order('id', { ascending: true }).limit(3);
    if (e2) await logError(`[VALIDATION][schedules.sample] code=${e2.code ?? ''} msg=${e2.message ?? ''}`);
    else await logInfo(`VALIDATION schedules sample (up to 3): ${JSON.stringify(data ?? [])}`);
  } catch (e) { await logError(`[VALIDATION][schedules] unexpected ${e?.message || e}`); }

  try {
    const { count, error } = await anon.from('schedule_places').select('schedule_id', { count: 'exact', head: true });
    if (error) await logError(`[VALIDATION][schedule_places.count] code=${error.code ?? ''} msg=${error.message ?? ''}`);
    else await logInfo(`VALIDATION schedule_places count = ${count ?? 0}`);
    const { data, error: e2 } = await anon.from('schedule_places').select('schedule_id,place_id,order_index,time_str').order('schedule_id', { ascending: true }).limit(3);
    if (e2) await logError(`[VALIDATION][schedule_places.sample] code=${e2.code ?? ''} msg=${e2.message ?? ''}`);
    else await logInfo(`VALIDATION schedule_places sample (up to 3): ${JSON.stringify(data ?? [])}`);
  } catch (e) { await logError(`[VALIDATION][schedule_places] unexpected ${e?.message || e}`); }

  await logInfo('VALIDATION Done');
}

async function upsertWithServiceRole(seed) {
  const svc = supabaseClient(SUPABASE_SERVICE_KEY);
  if (!svc) {
    await logError('SERVICE client not initialized. Ensure SUPABASE_SERVICE_SECRET (preferred) or SUPABASE_SERVICE_ROLE and URL are set.');
    return;
  }
  await logInfo(`[MODE] Insert-only = ${INSERT_ONLY ? 'ON' : 'OFF'}`);
  await logInfo(`[UPLOAD] Using service client (masked) urlHost=${(new URL(SUPABASE_URL)).host} svc=${mask(SUPABASE_SERVICE_KEY)}`);

  // Sanitize per table to match schema
  const categories = sanitizeCategories(Array.isArray(seed.categories) ? seed.categories : []);
  const places = sanitizePlaces(Array.isArray(seed.places) ? seed.places : []);
  const schedules = sanitizeSchedules(Array.isArray(seed.schedules) ? seed.schedules : []);
  const schedule_places = sanitizeSchedulePlaces(Array.isArray(seed.schedule_places) ? seed.schedule_places : []);

  await logInfo('[DDL] Skipped programmatic DDL. Apply schema/policies in Supabase Studio or via server.');

  if (categories.length) {
    await logInfo(`[UPLOAD] Upserting categories (${categories.length})`);
    let resp;
    if (INSERT_ONLY) {
      resp = await svc.from('categories').upsert(categories, { onConflict: 'key', ignoreDuplicates: true });
    } else {
      resp = await svc.from('categories').upsert(categories, { onConflict: 'key' });
    }
    const { error, status } = resp;
    if (error) await logError(`[UPLOAD][categories] status=${status} code=${error.code ?? ''} msg=${error.message ?? ''}`);
    else await logInfo('[UPLOAD][categories] ok');
  } else {
    await logWarn('[UPLOAD] categories is empty; skipping');
  }

  if (places.length) {
    await logInfo(`[UPLOAD] Upserting places (${places.length})`);
    let resp;
    if (INSERT_ONLY) {
      resp = await svc.from('places').upsert(places, { ignoreDuplicates: true });
    } else {
      resp = await svc.from('places').upsert(places);
    }
    const { error, status } = resp;
    if (error) await logError(`[UPLOAD][places] status=${status} code=${error.code ?? ''} msg=${error.message ?? ''}`);
    else await logInfo('[UPLOAD][places] ok');
  } else {
    await logWarn('[UPLOAD] places is empty; skipping');
  }

  if (schedules.length) {
    await logInfo(`[UPLOAD] Upserting schedules (${schedules.length})`);
    const { error, status } = await svc.from('schedules').upsert(schedules, { ignoreDuplicates: INSERT_ONLY });
    if (error) await logError(`[UPLOAD][schedules] status=${status} code=${error.code ?? ''} msg=${error.message ?? ''}`);
    else await logInfo('[UPLOAD][schedules] ok');
  } else {
    await logInfo('[UPLOAD] schedules empty; skipping');
  }

  if (schedule_places.length) {
    await logInfo(`[UPLOAD] Upserting schedule_places (${schedule_places.length})`);
    const { error, status } = await svc.from('schedule_places').upsert(schedule_places, { ignoreDuplicates: INSERT_ONLY });
    if (error) await logError(`[UPLOAD][schedule_places] status=${status} code=${error.code ?? ''} msg=${error.message ?? ''}`);
    else await logInfo('[UPLOAD][schedule_places] ok');
  } else {
    await logInfo('[UPLOAD] schedule_places empty; skipping');
  }
}

async function main() {
  await logInfo('ETL start');
  await logInfo(`ENV urlHost=${(SUPABASE_URL ? new URL(SUPABASE_URL).host : 'undefined')} anon=${mask(SUPABASE_ANON)} svc=${mask(SUPABASE_SERVICE_KEY)}`);

  await generateSchemaAndDocsPlaceholders();

  const seed = await loadOrCreateSeed();

  await writeFileSafe(SEED_JSON, JSON.stringify(seed, null, 2));
  await logInfo(`Seed JSON written: ${SEED_JSON} (categories=${seed.categories?.length ?? 0}, places=${seed.places?.length ?? 0}, schedules=${seed.schedules?.length ?? 0}, schedule_places=${seed.schedule_places?.length ?? 0})`);

  await upsertWithServiceRole(seed);

  await validateWithAnon();

  await logInfo('ETL completed.');
}

main().catch(async (e) => {
  await logError(`ETL fatal: ${e?.stack || e?.message || e}`);
  process.exit(1);
});